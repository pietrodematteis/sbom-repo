
name: Collect SBOMs across repositories

on:
  workflow_dispatch:
    inputs:
      owner:
        description: "GitHub org or username to scan (e.g. acme-corp)"
        required: true
      repo_filter:
        description: "Optional regex to include repos (applied to repo name)"
        required: false
        default: ""
      branch:
        description: "Branch to search (default = repo default branch)"
        required: false
        default: ""
      sbom_name_regex:
        description: "Regex to match SBOM file names/assets"
        required: false
        default: '(?i)(^|[-_.])(?:sbom|cyclonedx|spdx|bom).*?\.(json|xml|cdx|spdx|bom)?$'
      prefer_release_assets:
        description: "Also check GitHub Releases assets for SBOM"
        type: boolean
        default: true
      include_actions_artifacts:
        description: "Also check GitHub Actions artifacts for SBOM"
        type: boolean
        default: true
      max_repos:
        description: "Max repositories to scan"
        required: false
        default: "200"
      artifact_retention_days:
        description: "Retention days for uploaded zips"
        required: false
        default: "7"

permissions:
  contents: read
  actions: read

jobs:
  collect-sboms:
    runs-on: ubuntu-latest

    env:
      OWNER: ${{ inputs.owner }}
      REPO_FILTER: ${{ inputs.repo_filter }}
      USER_BRANCH: ${{ inputs.branch }}
      SBOM_NAME_REGEX: ${{ inputs.sbom_name_regex }}
      PREFER_RELEASE: ${{ inputs.prefer_release_assets }}
      INCLUDE_ACTIONS: ${{ inputs.include_actions_artifacts }}
      MAX_REPOS: ${{ inputs.max_repos }}

      # Prefer PAT if provided (recommended for cross-repo private access and Actions artifacts)
      GH_TOKEN: ${{ secrets.SBOM_TOKEN != '' && secrets.SBOM_TOKEN || github.token }}

    steps:
      - name: Checkout (not strictly required)
        uses: actions/checkout@v4

      - name: Verify GitHub CLI and jq
        run: |
          set -euo pipefail
          gh --version
          jq --version

      - name: Collect SBOMs
        run: |
          set -euo pipefail
          shopt -s nullglob

          echo "::group::List repositories"
          repos_json=$(gh repo list "$OWNER" --limit "$MAX_REPOS" --json name,archived,isEmpty,visibility,defaultBranchRef)
          echo "$repos_json" | jq -r '.[] | [.name, .archived, .isEmpty, .defaultBranchRef.name] | @tsv'
          echo "::endgroup::"

          mkdir -p out zips

          # helper: test name via regex (POSIX)
          name_matches() {
            local name="$1"
            local regex="${SBOM_NAME_REGEX}"
            python3 - << 'PY' "$name" "$regex"
import os, re, sys
name, reg = sys.argv[1], sys.argv[2]
print("1" if re.search(reg, name) else "0")
PY
          }

          # Enumerate eligible repos
          mapfile -t repos < <(echo "$repos_json" \
            | jq -r '.[] | select(.archived==false and .isEmpty==false) | .name')

          for repo in "${repos[@]}"; do
            # Repo name filter (if provided)
            if [[ -n "$REPO_FILTER" ]] && ! [[ "$repo" =~ $REPO_FILTER ]]; then
              echo "Skip $repo (does not match repo_filter)"
              continue
            fi

            echo ""
            echo "===================="
            echo "Processing: $OWNER/$repo"
            echo "===================="

            outdir="out/$repo"
            mkdir -p "$outdir"
            found=0

            # Determine branch
            default_branch=$(echo "$repos_json" | jq -r ".[] | select(.name==\"$repo\") | .defaultBranchRef.name // empty")
            branch="${USER_BRANCH:-$default_branch}"
            echo "Using branch: ${branch:-<none>}"

            echo "::group::Search in-branch"
            if [[ -n "$branch" ]]; then
              # Try several filename-specific queries to reduce search noise
              declare -a code_queries=(
                "filename:sbom.json"
                "filename:sbom.xml"
                "filename:bom.xml"
                "filename:cyclonedx.json"
                "filename:cyclonedx.xml"
                "filename:spdx.json"
                "path:sbom"
                "path:.sbom"
              )

              downloaded=0
              for q in "${code_queries[@]}"; do
                # Use code search to find candidate paths, then fetch via contents API at the desired ref
                paths=$(gh api /search/code -f q="repo:$OWNER/$repo $q" --jq '.items[].path' 2>/dev/null || true)
                if [[ -n "$paths" ]]; then
                  while IFS= read -r path; do
                    # Get metadata to know the file name and to ensure it's a file
                    meta=$(gh api "/repos/$OWNER/$repo/contents/${path}" -f ref="$branch" 2>/dev/null || true)
                    if [[ -n "$meta" ]] && [[ "$(echo "$meta" | jq -r '.type')" == "file" ]]; then
                      fname=$(echo "$meta" | jq -r '.name')
                      # Check against provided regex
                      if [[ $(name_matches "$fname") == "1" ]]; then
                        echo "Downloading in-branch SBOM: $path @ $branch"
                        # Decode base64 content to file
                        echo "$meta" | jq -r '.content' | tr -d '\n' | base64 --decode > "$outdir/$fname" || true
                        downloaded=1
                      fi
                    fi
                  done <<< "$paths"
                fi
              done

              if [[ $downloaded -eq 1 ]]; then
                found=1
              fi
            else
              echo "No branch available to search."
            fi
            echo "::endgroup::"

            # Check Releases assets if requested and not yet found
            if [[ $found -eq 0 && "${PREFER_RELEASE}" == "true" ]]; then
              echo "::group::Search GitHub Releases assets"
              # List all releases (paginate) and their assets
              # Download assets with names matching regex
              rel_assets=$(gh api "/repos/$OWNER/$repo/releases" --paginate --jq '.[] | .assets[] | [.url, .name] | @tsv' 2>/dev/null || true)
              rel_dl=0
              if [[ -n "$rel_assets" ]]; then
                while IFS=$'\t' read -r asset_url asset_name; do
                  [[ -z "$asset_url" || -z "$asset_name" ]] && continue
                  if [[ $(name_matches "$asset_name") == "1" ]]; then
                    echo "Downloading Release asset: $asset_name"
                    # Download binary asset
                    gh api -H "Accept: application/octet-stream" "$asset_url" > "$outdir/$asset_name" || true
                    rel_dl=1
                  fi
                done <<< "$rel_assets"
              fi
              if [[ $rel_dl -eq 1 ]]; then
                found=1
              fi
              echo "::endgroup::"
            fi

            # Check Actions artifacts if requested and not yet found
            if [[ $found -eq 0 && "${INCLUDE_ACTIONS}" == "true" ]]; then
              echo "::group::Search GitHub Actions artifacts"
              # List artifacts (paginate), download those matching regex (zip), then expand
              arts=$(gh api "/repos/$OWNER/$repo/actions/artifacts" --paginate --jq '.artifacts[] | select(.expired==false) | [.id, .name] | @tsv' 2>/dev/null || true)
              act_dl=0
              if [[ -n "$arts" ]]; then
                while IFS=$'\t' read -r art_id art_name; do
                  [[ -z "$art_id" || -z "$art_name" ]] && continue
                  if [[ $(name_matches "$art_name") == "1" ]]; then
                    zip_path="$outdir/${art_name}.zip"
                    echo "Downloading Actions artifact: $art_name"
                    gh api "/repos/$OWNER/$repo/actions/artifacts/$art_id/zip" > "$zip_path" || true
                    if [[ -s                    if [[ -s "$zip_path" ]]; then
                      unzip -o -q "$zip_path" -d "$outdir" || true
                      rm -f "$zip_path"
                      act_dl=1
                    fi
                  fi
                done <<< "$arts"
              fi
              if [[ $act_dl -eq 1 ]]; then
                found=1
              fi
              echo "::endgroup::"
            fi

            # If we found anything, zip the repo folder; otherwise delete the empty folder
            if [[ -n "$(ls -A "$outdir" 2>/dev/null)" ]]; then
              zipname="zips/${repo}-sboms.zip"
              (cd out && zip -r -q "../$zipname" "$repo")
              echo "Created: $zipname"
            else
              rmdir "$outdir" || true
              echo "No SBOM found for $OWNER/$repo"
            fi

            # be gentle on the API
            sleep 0.5
          done

      - name: Upload zipped SBOMs
        if: ${{ hashFiles('zips/*.zip') != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: collected-sboms
          path: zips/*.zip
